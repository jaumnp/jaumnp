<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Commit Raid ‚Ä¢ jaumnp</title>
  <style>
    :root{
      --bg:#06080d;
      --panel:rgba(8,12,18,.72);
      --panel-strong:rgba(10,14,22,.84);
      --line:rgba(121,168,255,.14);
      --text:#edf2ff;
      --muted:#9fb0d8;
      --accent:#79a8ff;
      --ok:#63ffa6;
      --warn:#ffd166;
      --danger:#ff5a7a;
      --pink:#ff80bf;
      --shadow:0 10px 28px rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:#05070c;
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    /* =========================
       CAMADAS (corre√ß√£o principal)
       ========================= */
    #game{
      position:fixed;
      inset:0;
      z-index:0;
      display:block;
      width:100vw;
      height:100vh;
      cursor:crosshair;
      background:transparent;
    }

    .hud{
      position:fixed;
      inset:0;
      z-index:10;
      pointer-events:none;
      background:transparent;
    }

    /* Overlays decorativos bem leves e atr√°s dos pain√©is */
    .chrome, .scanlines{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:1;
    }

    .chrome{
      background:
        radial-gradient(circle at 50% 55%, rgba(121,168,255,.05), transparent 42%),
        radial-gradient(circle at 50% 55%, transparent 60%, rgba(0,0,0,.30) 100%);
      opacity:.10; /* bem mais leve */
      mix-blend-mode:screen;
    }

    .scanlines{
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.018) 0px,
        rgba(255,255,255,.018) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      opacity:.08; /* bem mais leve */
      mix-blend-mode:soft-light;
    }

    /* Pain√©is e UI √∫teis acima dos overlays */
    .topbar, .rightMini, .weapon-bar, .bottom-left, .center-card, .banner, .corner {
      position:absolute;
      z-index:20;
    }

    .panel{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      padding:10px 12px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(6px);
    }

    .panel.strong{
      background:var(--panel-strong);
      border-color: rgba(121,168,255,.12);
      box-shadow: 0 0 0 1px rgba(121,168,255,.06) inset, var(--shadow);
    }

    .topbar{
      top:14px;
      left:14px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      max-width:min(760px, calc(100vw - 28px));
      flex-wrap:wrap;
    }

    .title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:800;
      font-size:13px;
      letter-spacing:.4px;
      margin-bottom:8px;
    }

    .dot{
      width:8px;height:8px;border-radius:50%;
      background:var(--ok);
      box-shadow:0 0 12px var(--ok);
      animation:pulse 1.8s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform:scale(1); opacity:.85; }
      50%{ transform:scale(1.22); opacity:1; }
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid rgba(255,255,255,.06);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      color:var(--muted);
      background:rgba(255,255,255,.02);
    }

    .stats{
      display:grid;
      grid-template-columns: repeat(3, minmax(74px,auto));
      gap:8px;
    }

    .stat{
      border:1px solid rgba(255,255,255,.05);
      border-radius:10px;
      background:rgba(255,255,255,.015);
      padding:6px 8px;
    }
    .stat .k{
      display:block;
      color:var(--muted);
      font-size:10px;
      margin-bottom:2px;
    }
    .stat .v{
      display:block;
      font-weight:800;
      font-size:14px;
      letter-spacing:.2px;
    }

    .meter{
      margin-top:8px;
      display:grid;
      grid-template-columns: 66px 1fr 48px;
      align-items:center;
      gap:8px;
      font-size:11px;
      color:var(--muted);
    }
    .meter b{
      color:var(--text);
      font-size:11px;
      text-align:right;
    }
    .bar{
      height:8px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.04);
      overflow:hidden;
      position:relative;
    }
    .bar > i{
      position:absolute;
      inset:0 auto 0 0;
      width:0%;
      border-radius:999px;
      display:block;
      box-shadow:0 0 12px currentColor;
      transition:width .12s linear;
    }

    .rightMini{
      top:14px;
      right:14px;
      width:min(280px, calc(100vw - 28px));
      display:grid;
      gap:12px;
    }

    .radarWrap{
      display:grid;
      grid-template-columns: 108px 1fr;
      gap:10px;
      align-items:center;
    }

    .radarBox{
      width:108px;
      height:108px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(255,255,255,.015);
      display:grid;
      place-items:center;
    }

    .radarMeta{
      display:grid;
      gap:4px;
      font-size:11px;
      color:var(--muted);
      line-height:1.25;
    }
    .radarMeta b{ color:var(--text); }

    .feed{
      margin-top:8px;
      display:grid;
      gap:5px;
      max-height:88px;
      overflow:hidden;
    }
    .feed-item{
      border-left:2px solid rgba(121,168,255,.3);
      padding-left:7px;
      color:var(--muted);
      font-size:10px;
      line-height:1.2;
    }
    .feed-item b{ color:var(--text); }

    .banner{
      left:50%;
      top:14px;
      transform:translateX(-50%);
      max-width:min(640px, calc(100vw - 28px));
      width:max-content;
      border-radius:12px;
      padding:9px 12px;
      background:rgba(8,12,18,.85);
      border:1px solid rgba(255,255,255,.07);
      box-shadow:var(--shadow);
      font-size:12px;
      font-weight:800;
      letter-spacing:.4px;
      opacity:0;
      transition:opacity .18s ease, transform .18s ease;
      pointer-events:none;
      text-align:center;
    }
    .banner.show{ opacity:1; }
    .banner.info{ border-color:rgba(121,168,255,.26); color:#d9e7ff; }
    .banner.ok{ border-color:rgba(99,255,166,.24); color:#d4ffea; }
    .banner.alert{ border-color:rgba(255,90,122,.28); color:#ffd8e0; }

    .weapon-bar{
      left:50%;
      bottom:14px;
      transform:translateX(-50%);
      display:flex;
      gap:8px;
      width:min(860px, calc(100vw - 28px));
      justify-content:center;
      flex-wrap:wrap;
    }

    .weapon-slot{
      min-width:160px;
      max-width:calc(50% - 4px);
      border-radius:12px;
      border:1px solid rgba(255,255,255,.06);
      background:var(--panel);
      box-shadow:var(--shadow);
      padding:9px 11px;
      color:var(--muted);
    }
    .weapon-slot.active{
      color:var(--text);
      border-color: rgba(121,168,255,.32);
      background: rgba(10,14,22,.9);
      box-shadow: 0 0 0 1px rgba(121,168,255,.10) inset, 0 0 20px rgba(121,168,255,.10), var(--shadow);
    }
    .weapon-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      font-size:11px;
      margin-bottom:4px;
    }
    .weapon-n{ color:var(--accent); font-weight:900; }
    .weapon-name{ font-weight:800; color:inherit; font-size:12px; }
    .weapon-sub{ font-size:10px; opacity:.95; }

    .bottom-left{
      left:14px;
      bottom:14px;
      max-width:min(420px, calc(100vw - 28px));
      font-size:11px;
      color:var(--muted);
      line-height:1.3;
    }
    .bottom-left b{ color:var(--text); }

    .center-card{
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      width:min(560px, calc(100vw - 28px));
      border-radius:14px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(6,8,14,.50); /* menos intrusivo */
      backdrop-filter: blur(4px);
      box-shadow:0 18px 48px rgba(0,0,0,.4);
      padding:14px 16px;
      text-align:center;
    }
    .center-card h2{
      margin:0;
      font-size:18px;
      letter-spacing:.4px;
    }
    .center-card p{
      margin:7px 0 0 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .center-grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:8px;
      margin-top:10px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.05);
      border-radius:10px;
      background:rgba(255,255,255,.02);
      padding:7px;
      color:var(--muted);
      font-size:11px;
    }
    .pill b{
      display:block;
      margin-top:2px;
      color:var(--text);
      font-size:14px;
    }

    .corner{
      width:26px;height:26px;border-color:rgba(121,168,255,.22);
      opacity:.9;
      z-index:15;
      pointer-events:none;
    }
    .corner.tl{ top:10px; left:10px; border-top:2px solid; border-left:2px solid; border-radius:10px 0 0 0; }
    .corner.tr{ top:10px; right:10px; border-top:2px solid; border-right:2px solid; border-radius:0 10px 0 0; }
    .corner.bl{ bottom:10px; left:10px; border-bottom:2px solid; border-left:2px solid; border-radius:0 0 0 10px; }
    .corner.br{ bottom:10px; right:10px; border-bottom:2px solid; border-right:2px solid; border-radius:0 0 10px 0; }

    /* Tela de boot (se der erro, o JS esconde sozinho) */
    .boot-overlay{
      position:fixed;
      inset:0;
      z-index:50;
      display:grid;
      place-items:center;
      background:radial-gradient(circle at 50% 30%, rgba(16,21,35,.92), rgba(4,6,10,.96));
      transition:opacity .35s ease;
      pointer-events:none;
    }
    .boot-overlay.hidden{ opacity:0; }

    .boot-card{
      width:min(560px, calc(100vw - 24px));
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(8,12,18,.78);
      backdrop-filter: blur(10px);
      box-shadow:0 24px 60px rgba(0,0,0,.45);
      padding:14px;
    }
    .boot-title{
      font-weight:900;
      letter-spacing:.8px;
      font-size:16px;
      margin-bottom:5px;
    }
    .boot-sub{
      color:var(--muted);
      font-size:12px;
      margin-bottom:10px;
    }
    .boot-progress{
      height:9px;
      border-radius:999px;
      overflow:hidden;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
    }
    .boot-progress > i{
      display:block;
      width:0%;
      height:100%;
      background:linear-gradient(90deg, rgba(121,168,255,.9), rgba(99,255,166,.9));
      box-shadow:0 0 16px rgba(121,168,255,.35);
      transition:width .16s ease;
    }
    .boot-lines{
      margin-top:10px;
      display:grid;
      gap:4px;
      max-height:90px;
      overflow:hidden;
      font-size:11px;
      color:var(--muted);
    }
    .boot-lines b{ color:var(--text); }

    @media (max-width: 980px){
      .rightMini{
        right:14px;
        top:auto;
        bottom:98px; /* acima da barra de armas */
        width:min(300px, calc(100vw - 28px));
      }
      .bottom-left{
        display:none; /* libera espa√ßo em telas menores */
      }
    }

    @media (max-width: 700px){
      .topbar{
        max-width:calc(100vw - 28px);
      }
      .stats{
        grid-template-columns: repeat(2, minmax(74px,auto));
      }
      .weapon-slot{
        min-width:100%;
        max-width:100%;
      }
      .rightMini{
        width:calc(100vw - 28px);
      }
      .radarWrap{
        grid-template-columns: 92px 1fr;
      }
      .radarBox{
        width:92px; height:92px;
      }
      .center-grid{
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <!-- HUD compacta -->
    <div class="topbar">
      <div class="panel strong">
        <div class="title"><span class="dot"></span> COMMIT RAID // jaumnp</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:6px;">
          <span class="chip" id="buildChip">dados: carregando‚Ä¶</span>
          <span class="chip" id="waveChip">wave 1</span>
          <span class="chip" id="remainChip">restantes 0</span>
        </div>

        <div class="stats">
          <div class="stat"><span class="k">HP</span><span class="v" id="uiHp">100</span></div>
          <div class="stat"><span class="k">Score</span><span class="v" id="uiScore">0</span></div>
          <div class="stat"><span class="k">Combo</span><span class="v" id="uiCombo">x0</span></div>
          <div class="stat"><span class="k">FPS</span><span class="v" id="uiFps">0</span></div>
          <div class="stat"><span class="k">Threat</span><span class="v" id="uiThreatText">LOW</span></div>
          <div class="stat"><span class="k">√öltimo</span><span class="v" id="uiLastShort">‚Äî</span></div>
        </div>

        <div class="meter">
          <span>Integridade</span>
          <div class="bar"><i id="hpBar" style="width:100%; color:#63ffa6;"></i></div>
          <b id="hpPct">100%</b>
        </div>

        <div class="meter">
          <span>Combo Heat</span>
          <div class="bar"><i id="comboBar" style="width:0%; color:#79a8ff;"></i></div>
          <b id="comboVal">0</b>
        </div>

        <div class="feed" id="killFeed"></div>
      </div>
    </div>

    <div class="rightMini">
      <div class="panel">
        <div style="font-weight:800; font-size:12px; letter-spacing:.4px; margin-bottom:8px;">TACTICAL RADAR</div>
        <div class="radarWrap">
          <div class="radarBox">
            <canvas id="radar" width="108" height="108" style="width:108px;height:108px;display:block;"></canvas>
          </div>
          <div class="radarMeta">
            <div><b>Total commits</b>: <span id="uiTotal">0</span></div>
            <div><b>Boss do raid</b>: <span id="uiBoss">‚Äî</span></div>
            <div><b>√öltimo alvo</b>: <span id="uiLastKill">‚Äî</span></div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="font-weight:800; font-size:12px; letter-spacing:.4px; margin-bottom:6px;">CONTROLES</div>
        <div style="font-size:11px; color:var(--muted); line-height:1.35;">
          Mouse mira ‚Ä¢ Clique atira ‚Ä¢ <b>1-4</b> troca arma ‚Ä¢ <b>R</b> reinicia ‚Ä¢ <b>Espa√ßo</b> atira
        </div>
      </div>
    </div>

    <div class="banner" id="banner"></div>

    <div class="weapon-bar" id="weaponBar"></div>

    <div class="bottom-left panel">
      <div><b>Commit Raid:</b> cada inimigo representa um <b>dia com commits</b>. Mais commits = mais HP, mais pontos e chance de virar elite/boss.</div>
      <div style="margin-top:6px;">Slots: <b>1</b> HTML/CSS/JS ‚Ä¢ <b>2</b> Node.js ‚Ä¢ <b>3</b> Java DMR ‚Ä¢ <b>4</b> React Pulse</div>
    </div>

    <div class="center-card" id="centerCard">
      <h2>Inicializando raid‚Ä¶</h2>
      <p>Carregando hist√≥rico de commits e montando os inimigos.</p>
      <div class="center-grid">
        <div class="pill">Perfil<b>jaumnp</b></div>
        <div class="pill">Modo<b>Commit Raid</b></div>
        <div class="pill">Visual<b>HUD Compact</b></div>
      </div>
    </div>

    <div class="corner tl"></div>
    <div class="corner tr"></div>
    <div class="corner bl"></div>
    <div class="corner br"></div>

    <div class="chrome"></div>
    <div class="scanlines"></div>
  </div>

  <div class="boot-overlay" id="bootOverlay">
    <div class="boot-card">
      <div class="boot-title">COMMIT RAID // BOOT SEQUENCE</div>
      <div class="boot-sub">Preparando arena e carregando dados de contribui√ß√µes.</div>
      <div class="boot-progress"><i id="bootBar"></i></div>
      <div class="boot-lines" id="bootLines"></div>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      // ====== GLOBAL ERROR HANDLERS (evita travar no overlay de boot) ======
      const bootOverlay = document.getElementById("bootOverlay");
      function emergencyHideBoot(reason) {
        console.error("[Commit Raid] emergency hide boot:", reason);
        if (bootOverlay) {
          bootOverlay.classList.add("hidden");
          setTimeout(() => { bootOverlay.style.display = "none"; }, 350);
        }
      }
      window.addEventListener("error", (e) => emergencyHideBoot(e.message || "window.error"));
      window.addEventListener("unhandledrejection", (e) => emergencyHideBoot(e.reason || "promise rejection"));

      // ====== CANVAS ======
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const radarCanvas = document.getElementById("radar");
      const rctx = radarCanvas.getContext("2d");

      let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      let W = 0, H = 0;

      function resize() {
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
      window.addEventListener("resize", resize);
      resize();

      // ====== UI refs ======
      const ui = {
        buildChip: document.getElementById("buildChip"),
        waveChip: document.getElementById("waveChip"),
        remainChip: document.getElementById("remainChip"),
        uiHp: document.getElementById("uiHp"),
        uiScore: document.getElementById("uiScore"),
        uiCombo: document.getElementById("uiCombo"),
        uiFps: document.getElementById("uiFps"),
        uiThreatText: document.getElementById("uiThreatText"),
        uiLastShort: document.getElementById("uiLastShort"),
        hpBar: document.getElementById("hpBar"),
        hpPct: document.getElementById("hpPct"),
        comboBar: document.getElementById("comboBar"),
        comboVal: document.getElementById("comboVal"),
        uiTotal: document.getElementById("uiTotal"),
        uiBoss: document.getElementById("uiBoss"),
        uiLastKill: document.getElementById("uiLastKill"),
        killFeed: document.getElementById("killFeed"),
        weaponBar: document.getElementById("weaponBar"),
        centerCard: document.getElementById("centerCard"),
        banner: document.getElementById("banner"),
        bootBar: document.getElementById("bootBar"),
        bootLines: document.getElementById("bootLines")
      };

      // ====== UTILS ======
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const rand = (a, b) => Math.random() * (b - a) + a;
      const fmt = (n) => new Intl.NumberFormat("pt-BR").format(Math.floor(n));

      function roundRect(c, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        c.beginPath();
        c.moveTo(x + rr, y);
        c.arcTo(x + w, y, x + w, y + h, rr);
        c.arcTo(x + w, y + h, x, y + h, rr);
        c.arcTo(x, y + h, x, y, rr);
        c.arcTo(x, y, x + w, y, rr);
        c.closePath();
      }

      function safeJSONClone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }

      // ====== WEAPONS ======
      const weapons = [
        { key:"1", name:"Frontend Burst", sub:"HTML/CSS/JS", damage:24, fireRate:7,  hitRadius:22, spread:0.028, color:"#79a8ff", crit:0.08 },
        { key:"2", name:"Node Stream",    sub:"Node.js",      damage:14, fireRate:12, hitRadius:28, spread:0.05,  color:"#63ffa6", crit:0.04 },
        { key:"3", name:"Java DMR",       sub:"Java",         damage:46, fireRate:3,  hitRadius:17, spread:0.016, color:"#ffd166", crit:0.14 },
        { key:"4", name:"React Pulse",    sub:"React",        damage:30, fireRate:5,  hitRadius:34, spread:0.022, color:"#ff80bf", crit:0.07, splash:20 },
      ];

      // ====== STATE ======
      const state = {
        username: "jaumnp",
        generatedAt: null,
        totalContributions: 0,

        time: 0,
        dtSmooth: 1 / 60,
        fps: 60,

        playerHp: 100,
        score: 0,
        combo: 0,
        wave: 1,
        threat: 0,

        weaponIndex: 0,
        fireCooldown: 0,

        mouseX: innerWidth / 2,
        mouseY: innerHeight / 2,

        queue: [],
        queueIndex: 0,
        active: [],
        particles: [],
        damageTexts: [],
        shells: [],
        flashes: [],
        feed: [],

        recoil: 0,
        cameraKickX: 0,
        cameraKickY: 0,

        spawnCooldown: 0.3,

        started: false,
        loading: true,
        gameOver: false,

        lastKilledLabel: "‚Äî",
        bossLabel: "‚Äî",
        bossSpawned: false,
        finalGrade: null,

        banner: { text:"", type:"info", timer:0 }
      };

      // ====== BOOT / BANNER / CENTER ======
      function bootLine(html, progress) {
        if (typeof progress === "number") {
          ui.bootBar.style.width = `${Math.round(progress * 100)}%`;
        }
        const div = document.createElement("div");
        div.innerHTML = html;
        ui.bootLines.prepend(div);
        while (ui.bootLines.children.length > 8) {
          ui.bootLines.removeChild(ui.bootLines.lastChild);
        }
      }

      function hideBoot() {
        if (!bootOverlay) return;
        bootOverlay.classList.add("hidden");
        setTimeout(() => { bootOverlay.style.display = "none"; }, 350);
      }

      function showBanner(text, type="info", time=2.0) {
        state.banner = { text, type, timer: time };
        ui.banner.textContent = text;
        ui.banner.className = `banner show ${type}`;
      }

      function updateBanner(dt) {
        if (state.banner.timer > 0) {
          state.banner.timer -= dt;
          if (state.banner.timer <= 0) {
            ui.banner.className = "banner";
          }
        }
      }

      function setCenter(title, text, pills = []) {
        ui.centerCard.innerHTML = `
          <h2>${title}</h2>
          <p>${text}</p>
          <div class="center-grid">
            ${pills.map(p => `<div class="pill">${p.k}<b>${p.v}</b></div>`).join("")}
          </div>
        `;
        ui.centerCard.style.display = "block";
      }

      function hideCenter() {
        ui.centerCard.style.display = "none";
      }

      function addFeed(message) {
        state.feed.unshift({ message, t: 6 });
        state.feed = state.feed.slice(0, 5);
        renderFeed();
      }

      function renderFeed() {
        ui.killFeed.innerHTML = state.feed.map(f => `<div class="feed-item">${f.message}</div>`).join("");
      }

      // ====== DATA (JSON + fallback) ======
      function fallbackCommitData() {
        const enemies = [];
        const now = new Date();
        let total = 0;

        for (let i = 139; i >= 0; i--) {
          const d = new Date(now);
          d.setDate(now.getDate() - i);

          const count = Math.random() < 0.47 ? 0 : Math.floor(Math.random() * 14) + 1;
          if (!count) continue;

          total += count;
          const kind = count >= 14 ? "boss" : count >= 8 ? "elite" : "grunt";
          enemies.push({
            date: d.toISOString().slice(0,10),
            count,
            lane: [-1, -0.5, 0, 0.5, 1][(i * 7) % 5],
            hp: 24 + count * (kind === "boss" ? 14 : kind === "elite" ? 12 : 9),
            speed: Math.min(1.2, 0.42 + count * 0.035),
            kind,
            label: `${count} commits`
          });
        }

        return {
          generatedAt: new Date().toISOString(),
          username: "jaumnp",
          totalContributions: total,
          enemies
        };
      }

      async function loadCommitData() {
        try {
          bootLine("<b>[BOOT]</b> inicializando renderer", 0.15);
          await new Promise(r => setTimeout(r, 80));

          bootLine("<b>[BOOT]</b> buscando docs/data/commit-enemies.json", 0.35);
          const res = await fetch("./data/commit-enemies.json?ts=" + Date.now(), { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          bootLine("<b>[OK]</b> dados recebidos", 0.62);
          const data = await res.json();
          if (!data || !Array.isArray(data.enemies)) throw new Error("JSON inv√°lido");

          bootLine(`<b>[OK]</b> ${data.enemies.length} hostis carregados`, 0.82);
          return data;
        } catch (err) {
          console.warn("[Commit Raid] usando fallback:", err);
          bootLine("<b>[WARN]</b> usando dados simulados (fallback)", 0.70);
          return fallbackCommitData();
        }
      }

      function buildQueue(data) {
        state.username = data.username || "jaumnp";
        state.generatedAt = data.generatedAt || null;
        state.totalContributions = data.totalContributions || 0;

        const sorted = [...(data.enemies || [])].sort((a, b) => a.date.localeCompare(b.date));

        let topBoss = null;
        state.queue = sorted.map((e, i) => {
          const obj = {
            id: `${i}_${e.date}`,
            date: e.date,
            count: Number(e.count || 0),
            lane: clamp(Number(e.lane ?? 0), -1, 1),
            x: Number(e.lane ?? 0),
            y: rand(-0.14, 0.12),
            z: 6 + rand(0.2, 0.8),
            wobble: rand(0, Math.PI * 2),
            hp: Math.max(14, Number(e.hp ?? (24 + (e.count || 1) * 10))),
            maxHp: Math.max(14, Number(e.hp ?? (24 + (e.count || 1) * 10))),
            speed: clamp(Number(e.speed ?? (0.45 + (e.count || 1) * 0.03)), 0.35, 1.25),
            kind: e.kind || ((e.count || 0) >= 14 ? "boss" : (e.count || 0) >= 8 ? "elite" : "grunt"),
            label: e.label || `${e.count || 0} commits`,
            bossPrime: false
          };
          if (!topBoss || obj.count > topBoss.count) topBoss = { index: i, count: obj.count, date: obj.date };
          return obj;
        });

        if (topBoss && state.queue[topBoss.index]) {
          state.queue[topBoss.index].bossPrime = true;
          state.bossLabel = `${topBoss.date} ‚Ä¢ ${topBoss.count} commits`;
        } else {
          state.bossLabel = "‚Äî";
        }

        // reset run
        state.queueIndex = 0;
        state.active = [];
        state.particles = [];
        state.damageTexts = [];
        state.shells = [];
        state.flashes = [];
        state.feed = [];
        state.playerHp = 100;
        state.score = 0;
        state.combo = 0;
        state.wave = 1;
        state.threat = 0;
        state.weaponIndex = 0;
        state.fireCooldown = 0;
        state.recoil = 0;
        state.cameraKickX = 0;
        state.cameraKickY = 0;
        state.spawnCooldown = 0.35;
        state.started = true;
        state.loading = false;
        state.gameOver = false;
        state.lastKilledLabel = "‚Äî";
        state.bossSpawned = false;
        state.finalGrade = null;

        renderWeaponBar();
        renderFeed();
        updateHUDStatic();
        updateHUDDynamic();

        if (state.queue.length === 0) {
          setCenter("Sem commits recentes", "Fa√ßa commits e rode a Action para gerar inimigos reais üòé", [
            { k: "Perfil", v: state.username },
            { k: "Hostis", v: "0" },
            { k: "Status", v: "Aguardando" }
          ]);
        } else {
          hideCenter();
          showBanner("RAID ONLINE ‚Ä¢ commits hostis detectados", "info", 2.0);
        }
      }

      function updateHUDStatic() {
        ui.uiTotal.textContent = fmt(state.totalContributions);
        ui.uiBoss.textContent = state.bossLabel;
        ui.uiLastKill.textContent = state.lastKilledLabel;
        ui.uiLastShort.textContent = "‚Äî";

        ui.buildChip.textContent = state.generatedAt
          ? "dados: " + new Date(state.generatedAt).toLocaleDateString("pt-BR")
          : "dados: fallback";
      }

      // ====== GAME MATH / PROJECTION ======
      function projectEnemy(e) {
        const p = 1 / (e.z * 0.23 + 0.09);
        const sx = W * 0.5 + (e.x + Math.sin(state.time * 2 + e.wobble) * 0.04) * (W * 0.34 * p);
        const sy = H * 0.54 + (e.y + (1 - e.z / 6.5) * 0.35) * (H * 0.74 * p);
        const r = clamp((26 + e.count * 2.35) * p, 10, e.bossPrime ? 140 : (e.kind === "boss" ? 118 : 94));
        return { sx, sy, r, p };
      }

      function screenShakeAmount() {
        let s = 0;
        for (const f of state.flashes) s += f.power * Math.max(0, f.t);
        return clamp(s, 0, 18) + state.recoil * 1.1;
      }

      // ====== EFFECTS ======
      function addParticles(x, y, count, color, scale=1) {
        for (let i = 0; i < count; i++) {
          state.particles.push({
            x, y,
            vx: rand(-180, 180) * scale,
            vy: rand(-180, 180) * scale,
            life: rand(0.15, 0.48),
            t: 1,
            color,
            size: rand(1.6, 3.2) * scale
          });
        }
      }

      function addDamageText(x, y, value, color, crit=false) {
        state.damageTexts.push({
          x, y,
          vy: crit ? -42 : -28,
          life: crit ? 0.75 : 0.55,
          t: 1,
          text: crit ? `CRIT ${value}` : `${value}`,
          color,
          crit
        });
      }

      function addShell() {
        state.shells.push({
          x: W * 0.58 + rand(-6, 8),
          y: H * 0.78 + rand(-4, 4),
          vx: rand(80, 180),
          vy: rand(-130, -70),
          life: rand(0.35, 0.65),
          rot: rand(0, Math.PI),
          vr: rand(-12, 12)
        });
      }

      function pushFlash(color, power) {
        state.flashes.push({ t: 1, power, color });
      }

      // ====== GAMEPLAY ======
      function spawnEnemy() {
        if (state.queueIndex >= state.queue.length) return;
        const e = safeJSONClone(state.queue[state.queueIndex++]);
        e.z = 6.5 + rand(-0.1, 0.35);
        e.x = e.lane + rand(-0.08, 0.08);
        e.y = rand(-0.16, 0.12);
        e.wobble = rand(0, Math.PI * 2);
        state.active.push(e);

        if ((e.bossPrime || e.kind === "boss") && !state.bossSpawned) {
          state.bossSpawned = true;
          showBanner(`‚ö† BOSS DETECTADO ‚Ä¢ ${e.date} ‚Ä¢ ${e.count} commits`, "alert", 3);
          addFeed(`<b>BOSS</b> ${e.date} ‚Ä¢ ${e.count} commits entrou na arena`);
        }
      }

      function fireWeapon() {
        if (state.loading || state.gameOver || !state.started) return;
        const w = weapons[state.weaponIndex];
        if (state.fireCooldown > 0) return;

        state.fireCooldown = 1 / w.fireRate;
        state.recoil += 1.8 + (w.damage * 0.015);
        state.cameraKickX += rand(-2.5, 2.5);
        state.cameraKickY += rand(-3.6, -1.6);

        pushFlash(w.color, 6 + w.damage * 0.11);
        addShell();

        let best = null;
        for (const e of state.active) {
          const pr = projectEnemy(e);
          const dx = state.mouseX - pr.sx;
          const dy = state.mouseY - pr.sy;
          const dist = Math.hypot(dx, dy);
          const spreadPenalty = (Math.random() * w.spread) * pr.r * 4.8;
          const hitThreshold = pr.r + w.hitRadius * 0.35 - spreadPenalty;
          if (dist <= hitThreshold) {
            if (!best || e.z < best.e.z) best = { e, pr };
          }
        }

        if (!best) {
          addParticles(state.mouseX, state.mouseY, 4, "rgba(255,255,255,.4)", 0.8);
          state.combo = 0;
          return;
        }

        const target = best.e;
        const pr = best.pr;
        const hitX = lerp(pr.sx, state.mouseX, 0.2);
        const hitY = lerp(pr.sy, state.mouseY, 0.2);

        let damage = w.damage;
        const crit = Math.random() < (w.crit || 0);
        if (crit) damage = Math.round(damage * 1.65);

        target.hp -= damage;
        addDamageText(hitX + rand(-6,6), hitY - rand(8,16), damage, w.color, crit);
        addParticles(hitX, hitY, crit ? 18 : 10, w.color, crit ? 1.15 : 1);

        if (w.splash) {
          for (const e of state.active) {
            if (e === target) continue;
            const p2 = projectEnemy(e);
            const d = Math.hypot(p2.sx - hitX, p2.sy - hitY);
            if (d < w.splash) {
              const splashDmg = Math.floor(w.damage * 0.34);
              e.hp -= splashDmg;
              addDamageText(p2.sx + rand(-5,5), p2.sy - 6, splashDmg, "rgba(255,128,191,.9)", false);
            }
          }
        }

        if (target.hp <= 0) {
          const kindMul = target.bossPrime ? 3.3 : target.kind === "boss" ? 2.4 : target.kind === "elite" ? 1.5 : 1;
          const bonus = Math.floor(target.count * 10 * kindMul * (1 + state.combo * 0.06));
          state.score += bonus;
          state.combo++;
          state.lastKilledLabel = `${target.date} ‚Ä¢ ${target.count} commits`;

          ui.uiLastKill.textContent = state.lastKilledLabel;
          ui.uiLastShort.textContent = target.count > 99 ? String(target.count) : `${target.count}`;

          addFeed(`<b>${target.kind.toUpperCase()}</b> eliminado ‚Ä¢ ${target.date} ‚Ä¢ +${fmt(bonus)} pts`);

          if (target.bossPrime) {
            showBanner("BOSS DO RAID ELIMINADO ‚úÖ", "ok", 2.4);
          }

          addParticles(pr.sx, pr.sy, target.bossPrime ? 30 : target.kind === "elite" ? 18 : 14, "#ffffff", target.bossPrime ? 1.2 : 1);
          state.active = state.active.filter(e => e !== target);
        }
      }

      function calculateThreat() {
        let t = 0;
        for (const e of state.active) {
          const weight = (1 / Math.max(0.18, e.z)) * (0.8 + e.count * 0.04);
          t += weight * (e.bossPrime ? 1.65 : e.kind === "elite" ? 1.2 : 1);
        }
        state.threat = clamp(t * 8, 0, 100);
      }

      function computeGrade() {
        const hp = state.playerHp;
        if (hp >= 85 && state.score > 3500) return "S";
        if (hp >= 65) return "A";
        if (hp >= 40) return "B";
        if (hp >= 15) return "C";
        return "D";
      }

      function updateHUDDynamic() {
        const remaining = Math.max(0, state.queue.length - state.queueIndex + state.active.length);

        ui.uiHp.textContent = String(state.playerHp);
        ui.uiScore.textContent = fmt(state.score);
        ui.uiCombo.textContent = `x${state.combo}`;
        ui.uiFps.textContent = String(Math.round(state.fps));

        ui.waveChip.textContent = `wave ${state.wave}`;
        ui.remainChip.textContent = `restantes ${remaining}`;

        const hpPct = clamp(state.playerHp, 0, 100);
        ui.hpBar.style.width = `${hpPct}%`;
        ui.hpPct.textContent = `${hpPct}%`;
        ui.hpBar.style.color = hpPct > 60 ? "#63ffa6" : hpPct > 30 ? "#ffd166" : "#ff5a7a";

        const comboPct = clamp(state.combo * 8, 0, 100);
        ui.comboBar.style.width = `${comboPct}%`;
        ui.comboVal.textContent = state.combo > 0 ? `x${state.combo}` : "0";
        ui.comboBar.style.color = state.combo > 8 ? "#ff80bf" : "#79a8ff";

        let threatText = "LOW";
        if (state.threat > 70) threatText = "HIGH";
        else if (state.threat > 35) threatText = "MID";
        ui.uiThreatText.textContent = threatText;
      }

      function update(dt) {
        state.time += dt;
        state.dtSmooth = lerp(state.dtSmooth, dt, 0.08);
        state.fps = 1 / Math.max(0.0001, state.dtSmooth);

        state.fireCooldown = Math.max(0, state.fireCooldown - dt);
        state.recoil = Math.max(0, state.recoil - dt * 9);
        state.cameraKickX = lerp(state.cameraKickX, 0, dt * 10);
        state.cameraKickY = lerp(state.cameraKickY, 0, dt * 10);

        updateBanner(dt);

        for (let i = state.feed.length - 1; i >= 0; i--) {
          state.feed[i].t -= dt;
          if (state.feed[i].t <= 0) state.feed.splice(i, 1);
        }
        renderFeed();

        if (!state.started || state.loading) return;

        if (!state.gameOver) {
          state.spawnCooldown -= dt;

          state.wave = 1 + Math.floor((state.queueIndex + state.score / 600) / 18);

          const maxActive = clamp(3 + Math.floor(state.wave * 0.55), 3, 9);
          if (state.spawnCooldown <= 0 && state.active.length < maxActive && state.queueIndex < state.queue.length) {
            spawnEnemy();
            const cadence = Math.max(0.2, 0.62 - state.wave * 0.028);
            state.spawnCooldown = cadence * rand(0.85, 1.18);
          }
        }

        // Enemies
        for (let i = state.active.length - 1; i >= 0; i--) {
          const e = state.active[i];
          e.z -= dt * (e.speed + state.wave * 0.018 + (e.bossPrime ? 0.04 : 0));
          e.wobble += dt * (0.7 + e.speed * 0.35);
          e.x += Math.sin(state.time * (0.8 + e.speed) + e.wobble) * dt * (e.bossPrime ? 0.03 : 0.02);
          e.x = clamp(e.x, -1.16, 1.16);

          if (e.hp <= 0) {
            state.active.splice(i,1);
            continue;
          }

          if (!state.gameOver && e.z <= 0.18) {
            const dmg = clamp(Math.floor(e.count * (e.bossPrime ? 2.4 : e.kind === "boss" ? 1.8 : 1)), 4, 35);
            state.playerHp = Math.max(0, state.playerHp - dmg);
            state.combo = 0;
            pushFlash("#ff5a7a", 12);
            state.cameraKickY += 4;
            addParticles(W/2, H*0.62, e.bossPrime ? 26 : 18, "#ff5a7a", 1.1);
            addFeed(`<b>HIT</b> ${e.date} atingiu o n√∫cleo ‚Ä¢ -${dmg} HP`);
            state.active.splice(i,1);

            if (state.playerHp <= 0) {
              state.gameOver = true;
              state.finalGrade = computeGrade();
              setCenter(
                "SYSTEM BREACH ‚ùå",
                "Os commits hostis romperam o n√∫cleo. Pressione R para tentar novamente.",
                [
                  { k: "Score", v: fmt(state.score) },
                  { k: "Rank", v: state.finalGrade },
                  { k: "HP", v: `${state.playerHp}%` }
                ]
              );
              showBanner("RAID FALHOU", "alert", 2.4);
            }
          }
        }

        // particles
        for (let i = state.particles.length - 1; i >= 0; i--) {
          const p = state.particles[i];
          p.life -= dt;
          p.t = Math.max(0, p.life / 0.5);
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.96;
          p.vy *= 0.96;
          if (p.life <= 0) state.particles.splice(i, 1);
        }

        // damage texts
        for (let i = state.damageTexts.length - 1; i >= 0; i--) {
          const d = state.damageTexts[i];
          d.life -= dt;
          d.t = Math.max(0, d.life / 0.75);
          d.y += d.vy * dt;
          d.x += Math.sin(state.time * 10 + i) * 9 * dt;
          if (d.life <= 0) state.damageTexts.splice(i, 1);
        }

        // shells
        for (let i = state.shells.length - 1; i >= 0; i--) {
          const s = state.shells[i];
          s.life -= dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vy += 260 * dt;
          s.rot += s.vr * dt;
          if (s.life <= 0) state.shells.splice(i, 1);
        }

        // flashes
        for (let i = state.flashes.length - 1; i >= 0; i--) {
          const f = state.flashes[i];
          f.t -= dt * 5;
          if (f.t <= 0) state.flashes.splice(i, 1);
        }

        calculateThreat();

        // Vit√≥ria
        if (!state.gameOver && state.queueIndex >= state.queue.length && state.active.length === 0 && state.queue.length > 0) {
          state.gameOver = true;
          state.finalGrade = computeGrade();
          setCenter(
            "RAID COMPLETO ‚úÖ",
            "Todos os commits hostis foram neutralizados. Pressione R para jogar novamente.",
            [
              { k: "Score", v: fmt(state.score) },
              { k: "Rank", v: state.finalGrade },
              { k: "HP", v: `${state.playerHp}%` }
            ]
          );
          showBanner(`MISS√ÉO CONCLU√çDA ‚Ä¢ RANK ${state.finalGrade}`, "ok", 3.0);
        }

        updateHUDDynamic();
      }

      // ====== DRAW ======
      function drawBackground() {
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, "#101726");
        g.addColorStop(0.45, "#090d15");
        g.addColorStop(1, "#06080c");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        // estrelas/ru√≠do digital
        const n = Math.floor((W * H) / 19000);
        ctx.globalAlpha = 0.33;
        for (let i = 0; i < n; i++) {
          const x = (i * 97 + Math.floor(state.time * 22)) % W;
          const y = (i * 59 + Math.floor(state.time * 10)) % H;
          ctx.fillStyle = (i % 8 === 0) ? "rgba(121,168,255,.9)" : "rgba(255,255,255,.65)";
          ctx.fillRect(x, y, 1.1, 1.1);
        }
        ctx.globalAlpha = 1;

        // glow horizonte
        const glow = ctx.createRadialGradient(W*0.5, H*0.55, 10, W*0.5, H*0.55, W*0.42);
        glow.addColorStop(0, "rgba(121,168,255,.12)");
        glow.addColorStop(1, "rgba(121,168,255,0)");
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, W, H);

        // horizonte
        ctx.strokeStyle = "rgba(121,168,255,.22)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, H * 0.54);
        ctx.lineTo(W, H * 0.54);
        ctx.stroke();

        // grid em perspectiva
        ctx.strokeStyle = "rgba(121,168,255,.10)";
        for (let i = -9; i <= 9; i++) {
          const x = W/2 + i * (W * 0.065);
          ctx.beginPath();
          ctx.moveTo(x, H);
          ctx.lineTo(W/2 + i*8, H * 0.54);
          ctx.stroke();
        }
        for (let i = 1; i <= 18; i++) {
          const t = i / 18;
          const y = lerp(H, H * 0.54, Math.pow(t, .66));
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(W, y);
          ctx.stroke();
        }
      }

      function drawEnemy(e) {
        const pr = projectEnemy(e);

        // sombra
        ctx.fillStyle = "rgba(0,0,0,.28)";
        ctx.beginPath();
        ctx.ellipse(pr.sx, pr.sy + pr.r * 0.82, pr.r * 0.72, pr.r * 0.26, 0, 0, Math.PI * 2);
        ctx.fill();

        // aura boss
        if (e.bossPrime || e.kind === "boss") {
          const aura = ctx.createRadialGradient(pr.sx, pr.sy, pr.r * 0.3, pr.sx, pr.sy, pr.r * 1.8);
          aura.addColorStop(0, e.bossPrime ? "rgba(255,90,122,.22)" : "rgba(255,209,102,.16)");
          aura.addColorStop(1, "rgba(255,90,122,0)");
          ctx.fillStyle = aura;
          ctx.beginPath();
          ctx.arc(pr.sx, pr.sy, pr.r * 1.8, 0, Math.PI * 2);
          ctx.fill();
        }

        let fill = "rgba(121,168,255,.94)";
        let stroke = "rgba(121,168,255,1)";
        let eye = "rgba(255,255,255,.95)";
        if (e.kind === "elite"){ fill = "rgba(255,209,102,.93)"; stroke = "rgba(255,209,102,1)"; eye = "#fff8d7"; }
        if (e.kind === "boss"){ fill = "rgba(255,90,122,.92)"; stroke = "rgba(255,90,122,1)"; eye = "#ffe6ee"; }
        if (e.bossPrime){ fill = "rgba(255,80,110,.95)"; stroke = "rgba(255,120,140,1)"; eye = "#ffffff"; }

        ctx.save();
        ctx.translate(pr.sx, pr.sy);
        ctx.rotate(Math.sin(state.time * 2 + e.wobble) * 0.07);

        const bodyW = pr.r * (e.bossPrime ? 1.55 : 1.34);
        const bodyH = pr.r * (e.bossPrime ? 1.25 : 1.04);
        const corner = Math.max(5, pr.r * 0.22);

        // casco
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 2;
        roundRect(ctx, -bodyW/2, -bodyH/2, bodyW, bodyH, corner);
        ctx.fill();
        ctx.stroke();

        // placa superior
        ctx.fillStyle = "rgba(7,10,15,.20)";
        roundRect(ctx, -bodyW*0.42, -bodyH*0.38, bodyW*0.84, bodyH*0.25, corner*0.7);
        ctx.fill();

        // "pixels" commits
        const dots = clamp(e.count, 1, 20);
        const cols = 4;
        for (let i = 0; i < dots; i++) {
          const cx = i % cols;
          const cy = Math.floor(i / cols);
          const px = -bodyW*0.34 + cx * (bodyW * 0.21);
          const py = -bodyH*0.14 + cy * (bodyH * 0.19);
          ctx.fillStyle = "rgba(8,11,16,.78)";
          ctx.fillRect(px, py, Math.max(2, pr.r*0.12), Math.max(2, pr.r*0.12));
        }

        // olho
        ctx.shadowBlur = pr.r * 0.35;
        ctx.shadowColor = eye;
        ctx.fillStyle = eye;
        ctx.beginPath();
        ctx.arc(0, -pr.r*0.03, Math.max(2.5, pr.r * 0.13), 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();

        // hp bar
        const hpW = pr.r * 1.52;
        const hpH = Math.max(4, pr.r * 0.12);
        const hpX = pr.sx - hpW/2;
        const hpY = pr.sy - pr.r - 14;
        ctx.fillStyle = "rgba(255,255,255,.10)";
        roundRect(ctx, hpX, hpY, hpW, hpH, hpH/2); ctx.fill();

        const hpRatio = clamp(e.hp / e.maxHp, 0, 1);
        ctx.fillStyle = e.bossPrime ? "#ff5a7a" : (e.kind === "elite" ? "#ffd166" : "#63ffa6");
        roundRect(ctx, hpX, hpY, hpW * hpRatio, hpH, hpH/2); ctx.fill();

        if (pr.r > 18) {
          ctx.font = "600 11px Inter, system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = "rgba(237,242,255,.9)";
          ctx.fillText(`${e.date} ‚Ä¢ ${e.count}`, pr.sx, pr.sy + pr.r + 16);
        }
      }

      function drawParticles() {
        for (const p of state.particles) {
          ctx.globalAlpha = clamp(p.t, 0, 1);
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
        ctx.globalAlpha = 1;
      }

      function drawDamageTexts() {
        for (const d of state.damageTexts) {
          ctx.globalAlpha = clamp(d.t,0,1);
          ctx.font = d.crit ? "800 13px Inter, system-ui, sans-serif" : "700 12px Inter, system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = d.color;
          if (d.crit) {
            ctx.shadowBlur = 12;
            ctx.shadowColor = d.color;
          }
          ctx.fillText(d.text, d.x, d.y);
          ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
      }

      function drawShells() {
        for (const s of state.shells) {
          ctx.save();
          ctx.globalAlpha = clamp(s.life / 0.65, 0, 1);
          ctx.translate(s.x, s.y);
          ctx.rotate(s.rot);
          ctx.fillStyle = "rgba(255,220,140,.9)";
          ctx.fillRect(-1.8, -0.9, 3.6, 1.8);
          ctx.restore();
        }
        ctx.globalAlpha = 1;
      }

      function drawReticle() {
        const x = state.mouseX;
        const y = state.mouseY;
        const spread = 12 + state.recoil * 2.1;
        const pulse = 1 + Math.sin(state.time * 8) * 0.06;

        ctx.strokeStyle = "rgba(237,242,255,.88)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.arc(x, y, 9 * pulse, 0, Math.PI * 2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(121,168,255,.8)";
        ctx.beginPath();
        ctx.moveTo(x - spread - 10, y); ctx.lineTo(x - spread, y);
        ctx.moveTo(x + spread, y); ctx.lineTo(x + spread + 10, y);
        ctx.moveTo(x, y - spread - 10); ctx.lineTo(x, y - spread);
        ctx.moveTo(x, y + spread); ctx.lineTo(x, y + spread + 10);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,.95)";
        ctx.beginPath();
        ctx.arc(x, y, 1.8, 0, Math.PI * 2);
        ctx.fill();

        const w = weapons[state.weaponIndex];
        if (state.fireCooldown > 0) {
          const ratio = clamp(state.fireCooldown * w.fireRate, 0, 1);
          ctx.strokeStyle = "rgba(255,255,255,.22)";
          ctx.lineWidth = 1.3;
          ctx.beginPath();
          ctx.arc(x, y, 14, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * ratio);
          ctx.stroke();
        }
      }

      function drawWeaponModel() {
        const w = weapons[state.weaponIndex];
        const baseX = W * 0.62 + state.cameraKickX * 0.15;
        const baseY = H * 0.84 + state.cameraKickY * 0.12 + state.recoil * 2.4;

        ctx.save();
        ctx.translate(baseX, baseY);
        ctx.rotate(-0.12 + Math.sin(state.time * 2) * 0.01);

        ctx.shadowBlur = 12;
        ctx.shadowColor = w.color;

        ctx.fillStyle = "rgba(14,18,28,.85)";
        roundRect(ctx, -8, -16, 120, 24, 7); ctx.fill();
        roundRect(ctx, 42, -24, 52, 10, 5); ctx.fill();
        roundRect(ctx, 90, -10, 24, 7, 4); ctx.fill();
        roundRect(ctx, 18, 4, 14, 28, 4); ctx.fill();
        roundRect(ctx, -2, -6, 18, 10, 4); ctx.fill();

        ctx.fillStyle = w.color;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(8, -7, 58, 2.4);
        ctx.globalAlpha = 1;

        if (state.fireCooldown > (1 / w.fireRate) * 0.65) {
          ctx.shadowBlur = 22;
          ctx.shadowColor = w.color;
          ctx.fillStyle = w.color;
          ctx.beginPath();
          ctx.moveTo(114, -7);
          ctx.lineTo(128 + rand(-2,2), -2);
          ctx.lineTo(114, 2);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
        ctx.shadowBlur = 0;
      }

      function drawVignetteAndFlashes() {
        // flashes
        for (const f of state.flashes) {
          ctx.globalAlpha = Math.max(0, f.t) * 0.11;
          ctx.fillStyle = f.color;
          ctx.fillRect(0, 0, W, H);
        }
        ctx.globalAlpha = 1;

        // vignette de dano
        if (state.playerHp < 35) {
          const a = (35 - state.playerHp) / 35;
          const vg = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.15, W/2, H/2, Math.max(W,H)*0.8);
          vg.addColorStop(0, "rgba(0,0,0,0)");
          vg.addColorStop(1, `rgba(255,90,122,${0.22 * a})`);
          ctx.fillStyle = vg;
          ctx.fillRect(0, 0, W, H);
        }
      }

      function drawCenterInfoText() {
        if (!state.loading && !state.gameOver && state.lastKilledLabel !== "‚Äî") {
          ctx.font = "600 12px Inter, system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = "rgba(237,242,255,.68)";
          ctx.fillText(`√öltimo alvo: ${state.lastKilledLabel}`, W/2, H - 82);
        }
      }

      function drawRadar() {
        const w = radarCanvas.width;
        const h = radarCanvas.height;
        rctx.clearRect(0, 0, w, h);

        rctx.fillStyle = "rgba(9,13,20,.95)";
        rctx.fillRect(0, 0, w, h);

        rctx.save();
        rctx.translate(w / 2, h / 2);

        // rings
        rctx.strokeStyle = "rgba(121,168,255,.18)";
        rctx.lineWidth = 1;
        [16, 28, 40, 52].forEach(r => {
          rctx.beginPath();
          rctx.arc(0, 0, r, 0, Math.PI * 2);
          rctx.stroke();
        });

        // cross
        rctx.beginPath();
        rctx.moveTo(-54, 0); rctx.lineTo(54, 0);
        rctx.moveTo(0, -54); rctx.lineTo(0, 54);
        rctx.stroke();

        // sweep
        const ang = state.time * 1.6;
        const sweep = rctx.createRadialGradient(0,0,8,0,0,56);
        sweep.addColorStop(0, "rgba(99,255,166,.20)");
        sweep.addColorStop(1, "rgba(99,255,166,0)");
        rctx.save();
        rctx.rotate(ang);
        rctx.fillStyle = sweep;
        rctx.beginPath();
        rctx.moveTo(0,0);
        rctx.arc(0,0,54,-0.18,0.18);
        rctx.closePath();
        rctx.fill();
        rctx.restore();

        // player center
        rctx.fillStyle = "rgba(237,242,255,.95)";
        rctx.beginPath();
        rctx.arc(0,0,2.6,0,Math.PI*2);
        rctx.fill();

        // enemies
        for (const e of state.active) {
          const rx = clamp(e.x, -1.2, 1.2) * 38;
          const rz = clamp(e.z, 0.18, 6.8);
          const ry = lerp(48, 6, 1 - ((rz - 0.18) / (6.8 - 0.18))); // closer = lower
          let col = "rgba(121,168,255,.95)";
          let rr = 2.2;
          if (e.kind === "elite"){ col = "rgba(255,209,102,.95)"; rr = 2.8; }
          if (e.kind === "boss" || e.bossPrime){ col = "rgba(255,90,122,.95)"; rr = e.bossPrime ? 3.7 : 3.2; }

          rctx.fillStyle = col;
          rctx.beginPath();
          rctx.arc(rx, ry, rr, 0, Math.PI * 2);
          rctx.fill();
        }

        rctx.restore();
      }

      function draw() {
        const shake = screenShakeAmount();
        const ox = (Math.random() - 0.5) * shake + state.cameraKickX;
        const oy = (Math.random() - 0.5) * shake + state.cameraKickY;

        ctx.save();
        ctx.translate(ox, oy);

        drawBackground();

        const sorted = [...state.active].sort((a, b) => b.z - a.z);
        for (const e of sorted) drawEnemy(e);

        // linha de mira leve
        if (!state.loading && !state.gameOver) {
          ctx.strokeStyle = "rgba(121,168,255,.10)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(W/2, H*0.84);
          ctx.lineTo(state.mouseX, state.mouseY);
          ctx.stroke();
        }

        drawParticles();
        drawShells();
        drawDamageTexts();
        drawWeaponModel();
        drawReticle();
        drawCenterInfoText();
        drawVignetteAndFlashes();

        ctx.restore();
      }

      // ====== INPUT ======
      window.addEventListener("mousemove", (e) => {
        state.mouseX = e.clientX;
        state.mouseY = e.clientY;
      });

      window.addEventListener("mousedown", () => fireWeapon());

      window.addEventListener("keydown", (e) => {
        if (e.key >= "1" && e.key <= "4") {
          state.weaponIndex = Number(e.key) - 1;
          renderWeaponBar();
        }
        if (e.key.toLowerCase() === "r") {
          buildQueue(window.__raidData || fallbackCommitData());
          showBanner("RAID REINICIADO", "info", 1.6);
        }
        if (e.code === "Space") {
          fireWeapon();
        }
      });

      // ====== WEAPON UI ======
      function renderWeaponBar() {
        ui.weaponBar.innerHTML = weapons.map((w, i) => `
          <div class="weapon-slot ${i === state.weaponIndex ? "active" : ""}">
            <div class="weapon-top">
              <span><span class="weapon-n">${i+1}</span> <span class="weapon-name">${w.name}</span></span>
              <span style="font-size:10px; opacity:.9;">${w.damage} dmg</span>
            </div>
            <div class="weapon-sub">${w.sub}</div>
          </div>
        `).join("");
      }
      renderWeaponBar();

      // ====== LOOP ======
      let lastTime = performance.now();
      function loop(now) {
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;

        update(dt);
        draw();
        drawRadar();

        requestAnimationFrame(loop);
      }

      // ====== BOOT ======
      async function boot() {
        try {
          setCenter("Inicializando raid‚Ä¶", "Carregando hist√≥rico de commits e montando os inimigos.", [
            { k:"Perfil", v:"jaumnp" },
            { k:"Modo", v:"Commit Raid" },
            { k:"Visual", v:"HUD Compact" }
          ]);

          bootLine("<b>[BOOT]</b> calibrando HUD", 0.08);
          await new Promise(r => setTimeout(r, 80));

          bootLine("<b>[BOOT]</b> calibrando ret√≠culo", 0.16);
          await new Promise(r => setTimeout(r, 80));

          const data = await loadCommitData();
          window.__raidData = data;

          bootLine("<b>[BOOT]</b> montando arena procedural", 0.90);
          await new Promise(r => setTimeout(r, 100));

          buildQueue(data);

          bootLine("<b>[READY]</b> raid online", 1);
          setTimeout(hideBoot, 220);

          requestAnimationFrame(loop);

          // Failsafe: se por algum motivo travar, esconde boot
          setTimeout(hideBoot, 3000);
        } catch (err) {
          console.error("[Commit Raid] boot error:", err);
          emergencyHideBoot(err);
          setCenter("Erro no carregamento", "O jogo entrou em fallback de emerg√™ncia. Recarregue a p√°gina (F5).", [
            { k:"Status", v:"Erro" },
            { k:"A√ß√£o", v:"Recarregar" },
            { k:"Modo", v:"Fallback" }
          ]);
          requestAnimationFrame(loop);
        }
      }

      boot();
    })();
  </script>
</body>
</html>
