<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Commit Raid ‚Ä¢ jaumnp</title>
  <style>
    :root{
      --bg:#090b10;
      --panel:rgba(10,12,18,.75);
      --line:rgba(140,170,255,.15);
      --text:#e8ecff;
      --muted:#9aa7cf;
      --danger:#ff5a7a;
      --ok:#63ffa6;
      --warn:#ffd166;
      --accent:#79a8ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(circle at 50% 20%, #121724 0%, #090b10 60%, #05060a 100%);
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    canvas{
      display:block;
      width:100vw;
      height:100vh;
      image-rendering:auto;
      cursor: crosshair;
    }

    .hud{
      position:fixed;
      inset:0;
      pointer-events:none;
    }

    .topbar{
      position:absolute;
      top:14px; left:14px; right:14px;
      display:flex; justify-content:space-between; gap:12px;
      font-size:14px;
    }

    .panel{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
      border-radius:12px;
      padding:10px 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,.25);
    }

    .title{
      font-weight:700; letter-spacing:.4px;
      display:flex; align-items:center; gap:8px;
    }
    .dot{
      width:8px; height:8px; border-radius:50%;
      background:var(--ok);
      box-shadow:0 0 12px var(--ok);
      display:inline-block;
    }

    .stats{
      display:flex; gap:10px; flex-wrap:wrap;
      color:var(--muted);
    }
    .stats b{color:var(--text)}

    .bottom-left{
      position:absolute;
      left:14px; bottom:14px;
      max-width:min(520px, 90vw);
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    .weapon-bar{
      position:absolute;
      left:50%; transform:translateX(-50%);
      bottom:16px;
      display:flex; gap:8px;
      pointer-events:none;
    }

    .weapon-slot{
      min-width:122px;
      padding:10px 12px;
      border-radius:12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.06);
      color:var(--muted);
      font-size:12px;
      text-align:left;
    }
    .weapon-slot.active{
      border-color: rgba(121,168,255,.5);
      box-shadow:0 0 0 1px rgba(121,168,255,.18) inset, 0 0 20px rgba(121,168,255,.12);
      color:var(--text);
    }
    .weapon-slot .n{font-weight:800; color:var(--accent); margin-right:6px}
    .weapon-slot .name{font-weight:700; color:inherit; display:block}
    .weapon-slot .sub{font-size:11px; opacity:.9}

    .center-msg{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      text-align:center;
      background:rgba(6,8,12,.65);
      border:1px solid rgba(255,255,255,.06);
      border-radius:14px;
      padding:14px 16px;
      min-width:280px;
    }
    .center-msg h2{margin:0 0 6px 0; font-size:18px}
    .center-msg p{margin:0; color:var(--muted); font-size:13px}

    .scanlines{
      position:fixed; inset:0; pointer-events:none;
      background:
        repeating-linear-gradient(to bottom,
          rgba(255,255,255,.02) 0px,
          rgba(255,255,255,.02) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px);
      mix-blend-mode:soft-light;
      opacity:.45;
    }

    .corner{
      position:absolute; width:26px; height:26px; border-color:rgba(121,168,255,.35);
    }
    .corner.tl{top:10px; left:10px; border-top:2px solid; border-left:2px solid; border-radius:10px 0 0 0}
    .corner.tr{top:10px; right:10px; border-top:2px solid; border-right:2px solid; border-radius:0 10px 0 0}
    .corner.bl{bottom:10px; left:10px; border-bottom:2px solid; border-left:2px solid; border-radius:0 0 0 10px}
    .corner.br{bottom:10px; right:10px; border-bottom:2px solid; border-right:2px solid; border-radius:0 0 10px 0}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="panel">
        <div class="title"><span class="dot"></span> COMMIT RAID // jaumnp</div>
        <div class="stats" id="leftStats"></div>
      </div>
      <div class="panel">
        <div class="stats" id="rightStats"></div>
      </div>
    </div>

    <div class="weapon-bar" id="weaponBar"></div>

    <div class="bottom-left panel">
      <div><b>Controles:</b> Mouse mira ‚Ä¢ Clique atira ‚Ä¢ <b>1</b> HTML/CSS/JS ‚Ä¢ <b>2</b> Node ‚Ä¢ <b>3</b> Java ‚Ä¢ <b>4</b> React ‚Ä¢ <b>R</b> reiniciar</div>
      <div style="margin-top:6px;">Os inimigos representam dias com contribui√ß√µes. Quanto mais commits em um dia, mais HP e mais pontua√ß√£o.</div>
    </div>

    <div class="center-msg" id="centerMsg">
      <h2>Prepare-se para o raid</h2>
      <p>Carregando dados de commits...</p>
    </div>

    <div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div>
  </div>

  <div class="scanlines"></div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    const weapons = [
      { key:"1", name:"Frontend Burst", sub:"HTML/CSS/JS", damage:24, fireRate:7, hitRadius:22, spread:0.03, color:"#79a8ff" },
      { key:"2", name:"Node Stream",    sub:"Node.js",      damage:14, fireRate:12, hitRadius:26, spread:0.05, color:"#63ffa6" },
      { key:"3", name:"Java DMR",       sub:"Java",         damage:44, fireRate:3, hitRadius:18, spread:0.018, color:"#ffd166" },
      { key:"4", name:"React Pulse",    sub:"React",        damage:30, fireRate:5, hitRadius:34, spread:0.025, color:"#ff80bf", splash:16 },
    ];

    const state = {
      username: "jaumnp",
      totalContributions: 0,
      playerHp: 100,
      score: 0,
      combo: 0,
      wave: 1,
      time: 0,
      weaponIndex: 0,
      mouseX: window.innerWidth / 2,
      mouseY: window.innerHeight / 2,
      fireCooldown: 0,
      spawnCooldown: 0,
      queueIndex: 0,
      queue: [],
      active: [],
      particles: [],
      flashes: [],
      gameOver: false,
      started: false,
      loading: true,
      lastKilledLabel: "",
      seedTick: 0
    };

    const leftStats = document.getElementById("leftStats");
    const rightStats = document.getElementById("rightStats");
    const centerMsg = document.getElementById("centerMsg");
    const weaponBar = document.getElementById("weaponBar");

    function renderWeaponBar() {
      weaponBar.innerHTML = weapons.map((w, i) => `
        <div class="weapon-slot ${i === state.weaponIndex ? "active" : ""}">
          <span class="n">${i+1}</span><span class="name">${w.name}</span>
          <div class="sub">${w.sub}</div>
        </div>
      `).join("");
    }
    renderWeaponBar();

    function setCenter(title, text) {
      centerMsg.innerHTML = `<h2>${title}</h2><p>${text}</p>`;
      centerMsg.style.display = "block";
    }
    function hideCenter() {
      centerMsg.style.display = "none";
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t){ return a + (b - a) * t; }
    function rand(min, max){ return Math.random() * (max - min) + min; }

    function fallbackCommitData() {
      const enemies = [];
      const now = new Date();
      for (let i = 90; i >= 0; i--) {
        const d = new Date(now);
        d.setDate(now.getDate() - i);
        const count = (Math.random() < 0.45) ? 0 : Math.floor(Math.random() * 12) + 1;
        if (!count) continue;
        enemies.push({
          date: d.toISOString().slice(0,10),
          count,
          level: count >= 8 ? "HIGH" : count >= 4 ? "MEDIUM" : "LOW",
          lane: ((i % 5) - 2) / 2,
          hp: 24 + count * 10,
          speed: 0.45 + Math.min(0.5, count * 0.03),
          kind: count >= 10 ? "boss" : (count >= 6 ? "elite" : "grunt"),
          label: `${count} commits`
        });
      }
      return {
        generatedAt: new Date().toISOString(),
        username: "jaumnp",
        totalContributions: enemies.reduce((a, e) => a + e.count, 0),
        enemies
      };
    }

    async function loadCommitRaidData() {
      try {
        const res = await fetch("./data/commit-enemies.json?ts=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        if (!data || !Array.isArray(data.enemies)) throw new Error("JSON inv√°lido");
        return data;
      } catch (err) {
        console.warn("Usando fallback de dados:", err);
        return fallbackCommitData();
      }
    }

    function buildQueue(data) {
      state.username = data.username || "jaumnp";
      state.totalContributions = data.totalContributions || 0;

      // Ordena por data (cronol√≥gico), mas promove alguns "bosses" naturalmente pelo count
      const sorted = [...data.enemies].sort((a,b) => a.date.localeCompare(b.date));
      state.queue = sorted.map((e, idx) => ({
        id: idx + "_" + e.date,
        date: e.date,
        count: e.count,
        level: e.level || (e.count >= 8 ? "HIGH" : e.count >= 4 ? "MEDIUM" : "LOW"),
        lane: clamp(Number(e.lane ?? 0), -1, 1),
        x: Number(e.lane ?? 0),
        y: rand(-0.15, 0.14),
        z: 6 + rand(0.2, 0.9),
        wobble: rand(0, Math.PI * 2),
        hp: Math.max(12, Number(e.hp ?? (24 + e.count * 10))),
        maxHp: Math.max(12, Number(e.hp ?? (24 + e.count * 10))),
        speed: clamp(Number(e.speed ?? (0.45 + e.count * 0.03)), 0.35, 1.2),
        kind: e.kind || (e.count >= 10 ? "boss" : e.count >= 6 ? "elite" : "grunt"),
        label: e.label || `${e.count} commits`
      }));

      state.queueIndex = 0;
      state.active = [];
      state.particles = [];
      state.flashes = [];
      state.playerHp = 100;
      state.score = 0;
      state.combo = 0;
      state.wave = 1;
      state.fireCooldown = 0;
      state.spawnCooldown = 0.3;
      state.gameOver = false;
      state.started = true;
      state.loading = false;

      if (state.queue.length === 0) {
        setCenter("Sem commits recentes", "Fa√ßa alguns commits e rode a Action para gerar inimigos üòé");
      } else {
        hideCenter();
      }
    }

    function spawnEnemy() {
      if (state.queueIndex >= state.queue.length) return;
      const e = structuredClone(state.queue[state.queueIndex++]);
      e.z = 6.6 + rand(-0.15, 0.35);
      e.x = e.lane + rand(-0.08, 0.08);
      e.y = rand(-0.18, 0.12);
      state.active.push(e);
    }

    function screenShakeAmount() {
      let s = 0;
      for (const f of state.flashes) s += f.power * f.t;
      return clamp(s, 0, 18);
    }

    function projectEnemy(e) {
      const perspective = 1 / (e.z * 0.23 + 0.09);
      const sx = W * 0.5 + (e.x + Math.sin(state.time * 2 + e.wobble) * 0.04) * (W * 0.34 * perspective);
      const sy = H * 0.53 + (e.y + (1 - e.z / 6.5) * 0.35) * (H * 0.75 * perspective);
      const r = clamp((26 + e.count * 2.4) * perspective, 12, e.kind === "boss" ? 130 : 95);
      return { sx, sy, r, p: perspective };
    }

    function addParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        state.particles.push({
          x, y,
          vx: rand(-160, 160),
          vy: rand(-160, 160),
          life: rand(0.18, 0.5),
          t: 1,
          color
        });
      }
    }

    function shoot() {
      if (state.loading || state.gameOver) return;
      const w = weapons[state.weaponIndex];
      if (state.fireCooldown > 0) return;
      state.fireCooldown = 1 / w.fireRate;
      state.flashes.push({ t: 1, power: 6 + w.damage * 0.12, color: w.color });

      // hitscan: escolhe o alvo mais pr√≥ximo no eixo Z que esteja sob a mira
      let best = null;
      for (const e of state.active) {
        const pr = projectEnemy(e);
        const dx = state.mouseX - pr.sx;
        const dy = state.mouseY - pr.sy;
        const dist = Math.hypot(dx, dy);
        const spreadPenalty = (Math.random() * w.spread) * pr.r * 4.5;
        const hitThreshold = pr.r + w.hitRadius * 0.35 - spreadPenalty;
        if (dist <= hitThreshold) {
          if (!best || e.z < best.e.z) best = { e, pr, dist };
        }
      }

      if (!best) {
        // tiro no vazio
        addParticles(state.mouseX, state.mouseY, 4, "rgba(255,255,255,.4)");
        state.combo = 0;
        return;
      }

      const target = best.e;
      const hitX = lerp(best.pr.sx, state.mouseX, 0.25);
      const hitY = lerp(best.pr.sy, state.mouseY, 0.25);

      target.hp -= w.damage;

      if (w.splash) {
        for (const e of state.active) {
          if (e === target) continue;
          const pr2 = projectEnemy(e);
          const d = Math.hypot(pr2.sx - hitX, pr2.sy - hitY);
          if (d < w.splash) {
            e.hp -= Math.floor(w.damage * 0.35);
          }
        }
      }

      addParticles(hitX, hitY, 10, w.color);

      if (target.hp <= 0) {
        const bonus = Math.floor(target.count * 10 * (1 + state.combo * 0.06));
        state.score += bonus;
        state.combo++;
        state.lastKilledLabel = `${target.date} ‚Ä¢ ${target.count} commits`;
        addParticles(best.pr.sx, best.pr.sy, target.kind === "boss" ? 28 : 16, "#ffffff");
        state.active = state.active.filter(e => e !== target);
      }
    }

    window.addEventListener("mousemove", (e) => {
      state.mouseX = e.clientX;
      state.mouseY = e.clientY;
    });
    window.addEventListener("mousedown", () => shoot());

    window.addEventListener("keydown", (e) => {
      if (e.key >= "1" && e.key <= "4") {
        state.weaponIndex = Number(e.key) - 1;
        renderWeaponBar();
      }
      if (e.key.toLowerCase() === "r") {
        state.seedTick++;
        buildQueue(window.__raidData || fallbackCommitData());
      }
      if (e.code === "Space") shoot();
    });

    function update(dt) {
      state.time += dt;
      if (!state.started) return;

      state.fireCooldown = Math.max(0, state.fireCooldown - dt);
      state.spawnCooldown -= dt;

      // Progress√£o de wave
      const processed = state.queueIndex + (window.__raidData?.enemies?.length ? 0 : 0);
      state.wave = 1 + Math.floor((state.queueIndex + state.score / 500) / 20);

      // Spawn control
      const maxActive = clamp(3 + Math.floor(state.wave * 0.5), 3, 8);
      if (!state.gameOver && state.spawnCooldown <= 0 && state.active.length < maxActive && state.queueIndex < state.queue.length) {
        spawnEnemy();
        const cadence = Math.max(0.22, 0.65 - state.wave * 0.03);
        state.spawnCooldown = cadence * rand(0.85, 1.15);
      }

      // Atualiza inimigos
      for (let i = state.active.length - 1; i >= 0; i--) {
        const e = state.active[i];
        e.z -= dt * (e.speed + state.wave * 0.02);
        e.wobble += dt * (0.7 + e.speed * 0.4);
        e.x += Math.sin(state.time * (0.8 + e.speed) + e.wobble) * dt * 0.02;
        e.x = clamp(e.x, -1.15, 1.15);

        if (e.hp <= 0) {
          state.active.splice(i,1);
          continue;
        }

        if (e.z <= 0.18) {
          const damage = clamp(Math.floor(e.count * (e.kind === "boss" ? 1.8 : 1.0)), 4, 30);
          state.playerHp = Math.max(0, state.playerHp - damage);
          state.combo = 0;
          state.flashes.push({ t: 1, power: 12, color: "#ff5a7a" });
          addParticles(W/2, H*0.62, 18, "#ff5a7a");
          state.active.splice(i, 1);
          if (state.playerHp <= 0) {
            state.gameOver = true;
            setCenter("SYSTEM BREACH", `Score: ${state.score} ‚Ä¢ Pressione R para reiniciar`);
          }
        }
      }

      // Part√≠culas
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.life -= dt;
        p.t = Math.max(0, p.life / 0.5);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.97;
        p.vy *= 0.97;
        if (p.life <= 0) state.particles.splice(i,1);
      }

      // flashes / shake
      for (let i = state.flashes.length - 1; i >= 0; i--) {
        const f = state.flashes[i];
        f.t -= dt * 5;
        if (f.t <= 0) state.flashes.splice(i,1);
      }

      // Encerramento da rodada
      if (!state.gameOver && state.queueIndex >= state.queue.length && state.active.length === 0 && state.queue.length > 0) {
        state.gameOver = true;
        setCenter("RAID COMPLETO ‚úÖ", `Score final: ${state.score} ‚Ä¢ Pressione R para jogar de novo`);
      }
    }

    function drawBackground() {
      // c√©u / n√©voa
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, "#111827");
      g.addColorStop(0.55, "#0b0f17");
      g.addColorStop(1, "#07090d");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // stars / pixels
      const starCount = Math.floor((W * H) / 18000);
      ctx.globalAlpha = 0.35;
      for (let i = 0; i < starCount; i++) {
        const x = (i * 97 + Math.floor(state.time * 20)) % W;
        const y = (i * 57 + Math.floor(state.time * 8)) % H;
        ctx.fillStyle = i % 7 === 0 ? "rgba(121,168,255,.8)" : "rgba(255,255,255,.7)";
        ctx.fillRect(x, y, 1.2, 1.2);
      }
      ctx.globalAlpha = 1;

      // horizonte
      ctx.strokeStyle = "rgba(121,168,255,.22)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, H * 0.53);
      ctx.lineTo(W, H * 0.53);
      ctx.stroke();

      // grid em perspectiva
      ctx.strokeStyle = "rgba(121,168,255,.12)";
      for (let i = -8; i <= 8; i++) {
        const x = W / 2 + i * (W * 0.07);
        ctx.beginPath();
        ctx.moveTo(x, H);
        ctx.lineTo(W / 2 + i * 8, H * 0.53);
        ctx.stroke();
      }
      for (let i = 1; i <= 18; i++) {
        const t = i / 18;
        const y = lerp(H, H * 0.53, Math.pow(t, 0.65));
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }

    function drawEnemy(e) {
      const pr = projectEnemy(e);

      // sombra
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.beginPath();
      ctx.ellipse(pr.sx, pr.sy + pr.r * 0.8, pr.r * 0.7, pr.r * 0.26, 0, 0, Math.PI * 2);
      ctx.fill();

      // cor por tier
      let fill = "rgba(121,168,255,.9)";
      let stroke = "rgba(121,168,255,1)";
      if (e.kind === "elite") { fill = "rgba(255,209,102,.9)"; stroke = "rgba(255,209,102,1)"; }
      if (e.kind === "boss")  { fill = "rgba(255,90,122,.9)";  stroke = "rgba(255,90,122,1)"; }

      // corpo "drone commit"
      ctx.save();
      ctx.translate(pr.sx, pr.sy);
      ctx.rotate(Math.sin(state.time * 2 + e.wobble) * 0.08);
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;

      const bodyW = pr.r * 1.35;
      const bodyH = pr.r * 1.05;
      roundRect(ctx, -bodyW/2, -bodyH/2, bodyW, bodyH, Math.max(6, pr.r * 0.22));
      ctx.fill();
      ctx.stroke();

      // "pixels" internos (commits)
      const dots = clamp(e.count, 1, 16);
      for (let i = 0; i < dots; i++) {
        const cols = 4;
        const cx = (i % cols);
        const cy = Math.floor(i / cols);
        const px = -bodyW * 0.32 + cx * (bodyW * 0.2);
        const py = -bodyH * 0.2 + cy * (bodyH * 0.18);
        ctx.fillStyle = "rgba(7,10,15,.8)";
        ctx.fillRect(px, py, Math.max(2, pr.r*0.14), Math.max(2, pr.r*0.14));
      }

      // "olho"
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.beginPath();
      ctx.arc(0, -pr.r * 0.05, Math.max(2.5, pr.r * 0.14), 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // HP bar
      const hpW = pr.r * 1.5;
      const hpH = 5;
      const hpX = pr.sx - hpW/2;
      const hpY = pr.sy - pr.r - 12;
      ctx.fillStyle = "rgba(255,255,255,.12)";
      roundRect(ctx, hpX, hpY, hpW, hpH, 3); ctx.fill();
      ctx.fillStyle = e.kind === "boss" ? "#ff5a7a" : (e.kind === "elite" ? "#ffd166" : "#63ffa6");
      roundRect(ctx, hpX, hpY, hpW * clamp(e.hp/e.maxHp, 0, 1), hpH, 3); ctx.fill();

      // label
      if (pr.r > 20) {
        ctx.font = "600 11px Inter, system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(232,236,255,.9)";
        ctx.fillText(`${e.date} ‚Ä¢ ${e.count}`, pr.sx, pr.sy + pr.r + 16);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawReticle() {
      const x = state.mouseX, y = state.mouseY;
      const pulse = 1 + Math.sin(state.time * 8) * 0.08;
      ctx.strokeStyle = "rgba(232,236,255,.85)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, 10 * pulse, 0, Math.PI * 2);
      ctx.stroke();

      ctx.strokeStyle = "rgba(121,168,255,.7)";
      ctx.beginPath();
      ctx.moveTo(x - 18, y); ctx.lineTo(x - 6, y);
      ctx.moveTo(x + 6, y); ctx.lineTo(x + 18, y);
      ctx.moveTo(x, y - 18); ctx.lineTo(x, y - 6);
      ctx.moveTo(x, y + 6); ctx.lineTo(x, y + 18);
      ctx.stroke();

      if (state.fireCooldown > 0) {
        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.beginPath();
        ctx.arc(x, y, 14, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * (state.fireCooldown * weapons[state.weaponIndex].fireRate));
        ctx.stroke();
      }
    }

    function drawParticles() {
      for (const p of state.particles) {
        ctx.globalAlpha = clamp(p.t, 0, 1);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2.2, 2.2);
      }
      ctx.globalAlpha = 1;
    }

    function drawFlashOverlay() {
      for (const f of state.flashes) {
        ctx.globalAlpha = Math.max(0, f.t) * 0.12;
        ctx.fillStyle = f.color;
        ctx.fillRect(0, 0, W, H);
      }
      ctx.globalAlpha = 1;
    }

    function drawHUDText() {
      const remaining = Math.max(0, state.queue.length - state.queueIndex + state.active.length);
      leftStats.innerHTML = `
        <span>HP: <b>${state.playerHp}</b></span>
        <span>Score: <b>${state.score}</b></span>
        <span>Combo: <b>x${state.combo}</b></span>
      `;
      rightStats.innerHTML = `
        <span>Wave: <b>${state.wave}</b></span>
        <span>Inimigos restantes: <b>${remaining}</b></span>
        <span>Total commits: <b>${state.totalContributions}</b></span>
      `;
    }

    function draw() {
      const shake = screenShakeAmount();
      const ox = (Math.random() - 0.5) * shake;
      const oy = (Math.random() - 0.5) * shake;

      ctx.save();
      ctx.translate(ox, oy);

      drawBackground();

      // ordenar por profundidade (mais longe primeiro)
      const sorted = [...state.active].sort((a,b) => b.z - a.z);
      for (const e of sorted) drawEnemy(e);

      // beam / aim line leve
      if (!state.loading && !state.gameOver) {
        ctx.strokeStyle = "rgba(121,168,255,.12)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(W/2, H*0.82);
        ctx.lineTo(state.mouseX, state.mouseY);
        ctx.stroke();
      }

      drawParticles();
      drawReticle();
      drawFlashOverlay();

      // √∫ltima kill
      if (state.lastKilledLabel && !state.gameOver) {
        ctx.font = "600 12px Inter, system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(232,236,255,.65)";
        ctx.fillText("√öltimo alvo: " + state.lastKilledLabel, W/2, H - 78);
      }

      ctx.restore();
      drawHUDText();
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    async function boot() {
      setCenter("Prepare-se para o raid", "Carregando dados de commits...");
      const data = await loadCommitRaidData();
      window.__raidData = data;
      buildQueue(data);
      requestAnimationFrame(loop);
    }

    boot();
  </script>
</body>
</html>